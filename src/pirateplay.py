# PUBLIC / PIRATE COMMUNITY RADIO # Project by Andres Colubri, Patrick Tierney and David Elliot## Pirateplay v0.0.1# This is the message playback application. It downloads the message audio files generated by the # Asterix server, and plays them back a number of times depending on the load on the system.# Programmed by Andres Colubriimport osimport randomimport sysimport timefrom HTMLParser import HTMLParserfrom urllib2 import urlopenimport pygletfrom pyglet.media import *from pyglet.window import key# URL of the folder in the remote server where the messages are being saved.AUDIO_URL = 'http://block.hardchats.com/~asterisk/voice_recordings/'# Supported audio formats.AUDIO_EXT = ['.wav', '.mp3', '.ogg']# Local folder where the audio files from the server are downloaded into.AUDIO_FOLDER = '.'# Chunk size used to download the audio files from the Asterix server.CHUNK_SIZE = 512# Time interval (in seconds) between two consecutive calls to the update function of the messages.UPDATE_PLAYBACK_INTERVAL = 1.0 / 30.0# Refresh time (in seconds) to update the list of audio files from the Asterix server.UPDATE_DOWNLOAD_INTERVAL = 1.0# List with all the message files that have been recorded in the remote server so far.remotefiles = []# List with the current active messages.messages = []class AudioSpider(HTMLParser):    """    This object crawls the AUDIO_URL looking for links to    supported audio files.    """    data = None    files = []    def __init__(self):        """        Intializes the object and creates a request to the server AUDIO_URL.        """        HTMLParser.__init__(self)        request = urlopen(AUDIO_URL)        self.data = request.read()    def get_audiofiles(self):        """        Returns a list with the found files.        """        self.files = []        self.feed(self.data)        return self.files    def handle_starttag(self, tag, attrs):        if tag == 'a' and attrs:            linkname = attrs[0][1]             linkext = os.path.splitext(linkname)[1]            if linkext in AUDIO_EXT:                self.files.append(linkname)class Message():    """    Encapsulates an audio message. Takes care of playing it back    a variable number of times, depending on how many other messages    are at the moment of creation on the queue.    """    playing = 0    filename = None    source = None    player = None    seconds = 0    minutes = 0    hours = 0    days = 0        remplays = 0    active = 0    def __init__(self, name):        self.filename = name        self.source = pyglet.media.load(name, streaming=False)        tmp = os.path.basename(name)        msginfo = os.path.splitext(tmp)[0]        parts = msginfo.split('-')        self.seconds = parts[0]        self.minutes = parts[1]        self.hours = parts[2]        self.days = parts[3]        self.active = 1        # The number of times the message will be played depends on how many        # messages currently are in the list.        self.remplays = max(1, 10 / 1 + len(messages))    def play(self):        self.player = self.source.play()        self.playing = 1        self.remplays = self.remplays - 1        print self.filename, 'started playback.'    def replay(self):        self.player = self.source.play()        self.playing = 1        self.remplays = self.remplays - 1        print self.filename, 're-started playback.'    def update(self, dt):        if self.player != None and self.player.source == None and self.playing == 1:            print self.filename, 'ended playback. Number of plays remaining: ', self.remplays            self.playing = 0            if 0 < self.remplays:                # Start new play...                self.replay()            else:                # Deactivating this message. Will be deleted in the update function.                self.active = 0window = pyglet.window.Window(320, 240)@window.eventdef on_key_press(symbol, modifiers):    """    Main window event handler.    """    if symbol == key.SPACE:        print "space key pressed"    elif symbol == key.BACKSPACE:        print "backspace key pressed"    elif symbol == key.ESCAPE:        print "escape key pressed"        window.has_exit = Truedef update_playback(dt):    """    This function gets executed every UPDATE_PLAYBACK_INTERVAL seconds     and calls the update functions of all the active messages.    """    for i in reversed(range(0, len(messages))):        messages[i].update(dt)        if not messages[i].active:            print "message", messages[i].filename, 'removed.'            messages.pop(i)pyglet.clock.schedule_interval(update_playback, UPDATE_PLAYBACK_INTERVAL)def download_new_audiofile(fn):    """    Downloads audio file fn from AUDIO_URL and saves it to local AUDIO_FOLDER.    Returns the complete path+name of the local file.    """    remotefn = os.path.join(AUDIO_URL, fn)    localfn = os.path.join(AUDIO_FOLDER, fn)     # Open up remote and local file    outfile = file(localfn, 'wb')    urlfile = urlopen(remotefn)    filesize = int(urlfile.info().get('Content-Length', None))    # Report beginning of download    print 'Beginning download of: %s' % remotefn    print '\tSize:',    if filesize is None:        print 'Unknown'    else:        print "%d KB" % (filesize / 1024)    print '\tTo local file:', localfn    start_time = time.time()    # Download our file    total_read = 0    while 1:        bytes = urlfile.read(CHUNK_SIZE)        bytes_read = len(bytes)            # If its zero we have hit the end of the file        if 0 == bytes_read:            break        # Write our data to the file        outfile.write(bytes)            # Update status information        total_read += bytes_read    # Report download stats    total_time = time.time() - start_time    total_read /= 1024    print '\nDownloaded: %d KB in %.2f seconds for %.2f KBs' % (total_read, total_time, total_read/total_time)    return localfndef update_download(dt):    """    This function gets executed  every UPDATE_DOWNLOAD_INTERVAL seconds    and calls the update functions of all the active messages.    """    spider = AudioSpider()    newfiles = spider.get_audiofiles()    for file in newfiles:        if not file in remotefiles:            # New audio file found on the server.            # Downloading it to the local folder:             remotefiles.append(file)            localfile = download_new_audiofile(file)            msg = Message(localfile)            messages.append(msg)            msg.play()pyglet.clock.schedule_interval(update_download, UPDATE_DOWNLOAD_INTERVAL)if __name__ == '__main__':    # Getting command line parameters.    for i in range(len(sys.argv)):        if 0 < i:            if sys.argv[i] == '--server-url':                AUDIO_URL = sys.argv[i+1]            if sys.argv[i] == '--loc-folder':                AUDIO_FOLDER = sys.argv[i+1]            if sys.argv[i] == '--ext-list':                extstr = sys.argv[i+1]                AUDIO_EXT = extstr.split(',')                # Adds a dot at the beginning of each element in AUDIO_EXT, using a lambda function:                AUDIO_EXT = map(lambda x: '.' + x, AUDIO_EXT)            if sys.argv[i] == '--chunk-size':                CHUNK_SIZE = float(sys.argv[i+1])            if sys.argv[i] == '--upd-play':                UPDATE_PLAYBACK_INTERVAL = int(sys.argv[i+1])            if sys.argv[i] == '--upd-dload':                UPDATE_DOWNLOAD_INTERVAL = int(sys.argv[i+1])    pyglet.app.run()
